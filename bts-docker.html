<!DOCTYPE html>
<html>
  <head>
    <title>Meet Docker!</title>
    <link rel="stylesheet" href="style.css"> 
  </head>
  <body>
    <div class="main-talk">
      <div class="section1">
        <p class="content-head-docker">Docker: Backstage</p>
        <img class="img-docker-2" src="static/images/docker-2.png">
      </div>
      <div class = "section2">
                <!--<div class="content-head-meet-sinjini">
         Meet Sinjini<span class="short-content"> (she/her) pronounced as [SHIN-jee-nee]</span>
</div>-->
       <div class="content-sub"> 
               In the previous post, we tried to understand how containerization has helped us, and we discussed the problems we used to face with traditional techniques.
          <br> <br>
            Today, we will focus on how Docker does it. Come on! Don’t tell me you haven’t thought, 'How does Docker make all of this look so easy?' even once. Well, you’re not alone. Docker can isolate an entire environment for an application, and the fact that it’s so lightweight and doesn’t require the hassle of installing anything is indeed fascinating.
          <br><br>
            Let’s dive into a scenario to know how...
        </div>
        <br>
        <div class="content-head">
          <span class="highlight-purple">Quick links</span>
          <ul class="content-sub">
            <li><a href="#scenario 1">Environmental inconsistency and Isolation issues </a></li>
            <li><a href="#scenario 2">Resource Intensive</a></li>
            <li><a href="#scenario 3">Scaling and other DevOps practices</a></li>
            <li><a href="#how_docker_helps">How docker helps</a></li>
          </ul>
        </div>
        <br>
        <div class="content-head">
          Scenario
        </div>
        <div class="content-sub">
          Say you want to run Nginx at port 8081 on your host system in isolation. So, you choose Docker. Before you create an isolated environment in your local system for your Nginx, you need to get an image. The concept of an image is very interesting here. Since images involve technical details like snapshots and deltas, which can be a bit off-topic, we will discuss this in our upcoming post.
          <br><br>
          For now, it’s enough to know that an image is like a blueprint, similar to a construction plan for a building. These images can be pulled directly from Docker Registry, or you can build your own image.
        </div>
        <br>
        <div class="content-sub highlight">
          <span class="highlight-purple" id="scenario 1"><b>Method 1: Pulling the Image from Docker Hub</b></span>
        </div>
        <br>
        <div class="content-sub">
          Type the following command in your terminal: <span class="highlight-purple"> <b>docker pull nginx</b></span>
          <br><br>
          <b>Note:</b> You must have Docker properly installed on your system. I prefer CLI over GUI. Come on, commands are the coolest!
          <br><br>
          Once you have pulled the image, you can check it by running:<span class="highlight-purple"> <b> docker images</b></span> or <span class="highlight-purple">docker image ls</span>
          <br><br>
        The output will show your image under the REPOSITORY column, with the tag 'latest.' Every image has a unique ID, unless you have two names for the same image. You can also check when it was created and the size of the image. 
       </div> 
        <br>
       <div class="content-sub highlight-purple highlight">
          <b>Method 2: Building Your Own Image</b>
        </div>
        <div class="content-sub">
          <br>
          This is a very useful method when you want to create your own image for an application that has specific dependencies and will be unavailable on Docker Hub unless you push your image there so others can pull it when needed.

To create your own image, you have to write a Dockerfile.txt first. By default or convention, we call it exactly "Dockerfile.txt," but you can name it anything.
          <br><br>
          Here’s an example:
          <br><br>
          <pre class="highlight-purple content-sub code">
                FROM ubuntu:latest
                RUN apt-get update && apt-get install -y nginx
                EXPOSE 80
                CMD ["nginx", "-g", "daemon off;"]
          </pre>
          Say you have a Windows host system, but you want to run Nginx inside an Ubuntu-based environment. The instruction FROM ubuntu:latest ensures you have an Ubuntu base image.
          <br><br>
          This creates the first layer of the image. Yes, layers! Every configuration and modification will be added as layers in the image. The next instruction, RUN apt-get update && apt-get install -y nginx, specifies that after the image has Ubuntu ready, it should come with the necessary modifications and tools before becoming a running container. Specifically, this command updates the packages and installs Nginx. This instruction will also create a new layer above the previous one.
        <br><br>
        EXPOSE 80 is the third instruction in our Dockerfile, indicating that the application will listen to port 80 inside the container. The EXPOSE command also creates a layer above the previous one, but it only adds metadata about the port, unlike the RUN command, which modifies files like /var/lib/apt/lists/ in the image.
          <br><br>
          Once EXPOSE 80 creates its layer, the last instruction, CMD ["nginx", "-g", "daemon off;"], specifies that once the image is built and a running container is created, the command that will run is nginx -g daemon off;. This command ensures that Nginx runs as a foreground process, not as a background process. This will also create a layer, similar to the EXPOSE instruction, adding metadata about the command the container will execute once it's built from that image.
          <br><br>
          The reason for delving this deep into the layers of a Docker image is to make you aware of how the sequence of instructions inside the Dockerfile matters. Also, you might be curious to know how a text file like a Dockerfile can bring about so many technical changes and be responsible for creating a container.
          <br><br>
          I will discuss more about the behind-the-scenes of images and their layers in the next post.
          <br><br>
          So now that you know how layers of images are created once we execute the Dockerfile with the command:
          <span class="highlight-purple">docker build -t <tag:version> .</span>
          <br><br>
          Once this image is built from a Dockerfile or pulled from the registry, you can create a running container out of it exactly the way you wanted. In this journey from creating a Dockerfile for building an image or pulling a built image and running a container from it, we run many commands or follow many steps. But how do they work in the background? Let’s discuss.
        </div>
        <br>
        <div class="content-head highlight-purple" id="how_docker_helps">
          <b>Behind The Scenes</b>
        </div>
        <br>
        <div class="content-sub">
          The key players working behind the scenes to ensure your containerization experience goes smoothly are:
          <br>
            <br><br>
            A small <span class="highlight-purple">suggestion</span>, if you want to try docker, <a class="highlight" href="https://docs.docker.com/">Docker's documentations</a> has done a very good job. Look for the sections <span class="highlight-purple">"Guide"</span> which specifically for concepts and introduction with docker utilities, <span class="highlight-purple">"Reference"</span> for CLI utilities and commands with proper explanation and <span class="highlight-purple">"Manuals"</span> for deep dive. <span class="highlight-purple">Happy exploring!</span>
          </div>
          <br>
          <div class="author-section author-section-border">
            <div class="footer-img-section">
              <img class="footer-img" src="static/images/profile2.png">
            </div>
            <div class="author-intro">
              <b>About Author:</b><br><b>Sinjini Banerjee</b><br><b>Cloud Engineer Intern at Nervescape LLP</b>
            </div>
          </div>
      </div>
        <div class="center"><br><br><br> © Copyright 2024. All right Reserved.</div>
        <div class="center">
          <p id="lastUpdated"></p>
        </div>
        
      </div>
    </div>
     <script>
        const lastModified = new Date(document.lastModified);
        const formattedDate = lastModified.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });

        document.getElementById('lastUpdated').textContent = `Last updated on: ${formattedDate}`;
    </script>

  </body>
</html>
